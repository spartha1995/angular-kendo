import { HostBinding, Input, ViewChild } from '@angular/core';
import { exportSVG, exportImage } from '@progress/kendo-drawing';
import { ResizeSensorComponent } from '@progress/kendo-angular-resize-sensor';
/**
 * @hidden
 */
var GaugeComponent = /** @class */ (function () {
    function GaugeComponent(configurationService, themeService, intlService, ngZone, rtl) {
        this.configurationService = configurationService;
        this.themeService = themeService;
        this.intlService = intlService;
        this.ngZone = ngZone;
        this.rtl = rtl;
        /**
         * The maximum number of times the Gauge resizes per second.
         * Defaults to `10`. To disable the automatic resizing, set it to `0`.
         */
        this.resizeRateLimit = 10;
        this.theme = null;
        this.direction = rtl ? 'rtl' : 'ltr';
    }
    Object.defineProperty(GaugeComponent.prototype, "className", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GaugeComponent.prototype, "dir", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    GaugeComponent.prototype.ngAfterViewChecked = function () {
        var _this = this;
        var updateMethod;
        if (!this.instance) {
            updateMethod = this.init;
        }
        else if (this.configurationService.hasChanges) {
            updateMethod = this.updateOptions;
        }
        else if (this.configurationService.valueChange) {
            updateMethod = this.setValues;
        }
        if (updateMethod) {
            this.ngZone.runOutsideAngular(function () {
                updateMethod.call(_this);
                _this.updateSize();
            });
        }
    };
    GaugeComponent.prototype.updateOptions = function () {
        this.instance.setOptions(this.configurationService.read());
    };
    GaugeComponent.prototype.setValues = function () {
        this.instance.allValues(this.configurationService.readValues());
    };
    GaugeComponent.prototype.ngOnChanges = function (changes) {
        this.configurationService.copyChanges('', changes);
    };
    GaugeComponent.prototype.ngOnDestroy = function () {
        if (this.instance) {
            this.instance.destroy();
        }
    };
    /**
     * Exports the Gauge as an image. The export operation is asynchronous and returns a promise.
     *
     * @param {ImageExportOptions} options - The parameters for the exported image.
     * @returns {Promise<string>} - A promise that will be resolved with a PNG image that is encoded as a Data URI.
     */
    GaugeComponent.prototype.exportImage = function (options) {
        if (options === void 0) { options = {}; }
        return this.exportVisual().then(function (visual) {
            return exportImage(visual, options);
        });
    };
    /**
     * Exports the Gauge as an SVG document. The export operation is asynchronous and returns a promise.
     *
     * @param {SVGExportOptions} options - The parameters for the exported file.
     * @returns {Promise<string>} - A promise that will be resolved with an SVG document that is encoded as a Data URI.
     */
    GaugeComponent.prototype.exportSVG = function (options) {
        if (options === void 0) { options = {}; }
        return this.exportVisual().then(function (visual) {
            return exportSVG(visual, options);
        });
    };
    /**
     * Exports the Gauge as a Drawing `Scene`.
     *
     * @returns {Promise<Group>} - A promise that will be resolved with the export visual.
     */
    GaugeComponent.prototype.exportVisual = function () {
        return Promise.resolve(this.instance.exportVisual());
    };
    /**
     * @hidden
     */
    GaugeComponent.prototype.onResize = function (_event) {
        if (this.autoResize) {
            this.resize();
        }
    };
    /**
     * Detects the size of the container and redraws the Gauge.
     * Resizing is automatic unless you set the `resizeRateLimit` option to `0`.
     */
    GaugeComponent.prototype.resize = function () {
        if (this.instance) {
            this.instance.resize();
        }
    };
    GaugeComponent.prototype.init = function () {
        if (typeof document === 'undefined') {
            return;
        }
        if (!this.surfaceElement) {
            return;
        }
        this.createInstance(this.surfaceElement.nativeElement, this.configurationService.read(), this.themeService.read(), {
            intlService: this.intlService,
            rtl: this.rtl
        });
    };
    Object.defineProperty(GaugeComponent.prototype, "autoResize", {
        get: function () {
            return this.resizeRateLimit > 0;
        },
        enumerable: true,
        configurable: true
    });
    GaugeComponent.prototype.updateSize = function () {
        this.resizeSensor.acceptSize();
    };
    GaugeComponent.propDecorators = {
        'gaugeArea': [{ type: Input },],
        'renderAs': [{ type: Input },],
        'resizeRateLimit': [{ type: Input },],
        'scale': [{ type: Input },],
        'transitions': [{ type: Input },],
        'surfaceElement': [{ type: ViewChild, args: ['surface',] },],
        'resizeSensor': [{ type: ViewChild, args: [ResizeSensorComponent,] },],
        'className': [{ type: HostBinding, args: ['class.k-gauge',] },],
        'dir': [{ type: HostBinding, args: ['attr.dir',] },],
    };
    return GaugeComponent;
}());
export { GaugeComponent };
