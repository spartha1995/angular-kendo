import * as tslib_1 from "tslib";
import { Component, ContentChild, ContentChildren, ElementRef, EventEmitter, HostBinding, HostListener, Inject, Input, Optional, Output, QueryList, ViewChildren, isDevMode } from '@angular/core';
import { RTL } from '@progress/kendo-angular-l10n';
import { Keys } from '../common/keys';
import { PanelBarExpandMode } from './panelbar-expand-mode';
import { PanelBarItemComponent } from './panelbar-item.component';
import { PanelBarService } from "./panelbar.service";
import { PanelBarItemTemplateDirective } from "./panelbar-item-template.directive";
import util from "../common/util";
/**
 * Represents the Kendo UI PanelBar component for Angular.
 */
let PanelBarComponent = 
// TODO: add styles as input prop
class PanelBarComponent {
    constructor(elementRef, eventService, rtl) {
        /**
         * Sets the expand mode of the PanelBar through the `PanelBarExpandMode` enum.
         *
         * The available modes are:
         * - `"single"`&mdash;Allows you to expand only one item at a time. Expanding an item collapses the previously expanded one.
         * - `"multiple"`&mdash;The default mode of the PanelBar.
         * Allows you to expand more than one item at a time. Items can also be toggled.
         * - `"full"`&mdash;Allows you to expand only one item at a time.
         * The expanded area occupies the entire height of the PanelBar. Requires you to set the `height` property.
         */
        this.expandMode = PanelBarExpandMode.Default;
        /**
         * Allows the PanelBar to modify the selected state of the items.
         */
        this.selectable = true;
        /**
         * Sets the animate state of the PanelBar.
         */
        this.animate = true;
        /**
         * Sets the height of the component when the `"full"` expand mode is used.
         * This option is ignored in the `"multiple"` and `"single"` expand modes.
         */
        this.height = "400px";
        /**
         * Fires each time the user interacts with a PanelBar item. The event data contains all items that are modified.
         */
        this.stateChange = new EventEmitter();
        this.tabIndex = 0;
        this.role = "tree";
        this.activeDescendant = "";
        this.isViewInit = true;
        this.focused = false;
        this._keepItemContent = false;
        this.updateChildrenHeight = () => {
            let childrenHeight = 0;
            const panelbarHeight = this.elementRef.nativeElement.offsetHeight;
            const contentOverflow = this.expandMode === PanelBarExpandMode.Full ? 'auto' : 'visible';
            this.childrenItems.forEach(item => {
                childrenHeight += item.headerHeight();
            });
            this.childrenItems.forEach(item => {
                item.contentHeight = PanelBarExpandMode.Full === this.expandMode ? (panelbarHeight - childrenHeight) + "px" : 'auto';
                item.contentOverflow = contentOverflow;
            });
        };
        this.updateAnimate = () => {
            this.allItems.forEach(item => {
                if (item.state === "activeWithoutAnimation") {
                    item.state = "active";
                }
            });
        };
        this.direction = rtl ? 'rtl' : 'ltr';
        this.keyBindings = this.computedKeys;
        this.elementRef = elementRef;
        this.eventService = eventService;
        this.eventService.children$.subscribe(event => this.onItemAction(event));
    }
    /**
     * When set to `true`, the component renders the content of all items and they are persisted in the DOM.
     * By default, this option is set to `false`.
     */
    get keepItemContent() {
        return this._keepItemContent;
    }
    set keepItemContent(keepItemContent) {
        this._keepItemContent = keepItemContent;
        this.eventService.onKeepContent(keepItemContent);
    }
    /**
     * Sets the items of the PanelBar as an array of `PanelBarItemModel` instances.
     */
    set items(data) {
        if (data) {
            this._items = util.parsePanelBarItems(data);
        }
    }
    get items() {
        return this._items;
    }
    get hostHeight() {
        return this.expandMode === PanelBarExpandMode.Full ? this.height : 'auto';
    }
    get overflow() {
        return this.expandMode === PanelBarExpandMode.Full ? "hidden" : "visible";
    }
    get dir() {
        return this.direction;
    }
    /**
     * @hidden
     */
    invertKeys(original, inverted) {
        return this.direction === 'rtl' ? inverted : original;
    }
    get computedKeys() {
        return {
            [Keys.space]: () => this.selectFocusedItem(),
            [Keys.enter]: () => this.selectFocusedItem(),
            [Keys.up]: () => this.focusPreviousItem(),
            [this.invertKeys(Keys.left, Keys.right)]: () => this.collapseItem(),
            [Keys.down]: () => this.focusNextItem(),
            [this.invertKeys(Keys.right, Keys.left)]: () => this.expandItem(),
            [Keys.end]: () => this.focusLastItem(),
            [Keys.home]: () => this.focusFirstItem()
        };
    }
    ngAfterViewChecked() {
        if (this.items) {
            this.childrenItems = this.viewChildItems.toArray();
            this.allItems = this.viewItems;
        }
        else {
            this.childrenItems = this.contentChildItems.toArray();
            this.allItems = this.contentItems.toArray();
        }
        if (this.isViewInit && this.childrenItems.length) {
            this.isViewInit = false;
            setTimeout(() => this.updateChildrenHeight());
        }
        this.validateConfiguration();
    }
    ngOnChanges(changes) {
        if (changes['height'] || changes['expandMode'] || changes["items"]) {
            if (this.childrenItems) {
                setTimeout(this.updateChildrenHeight);
            }
        }
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    onComponentClick(event) {
        const itemClicked = this.visibleItems().some((item) => {
            return item.header.nativeElement.contains(event.target);
        });
        if (!this.focused && itemClicked) {
            this.elementRef.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onComponentFocus() {
        this.eventService.onFocus();
        this.focused = true;
        if (this.allItems.length > 0) {
            const visibleItems = this.visibleItems();
            const focusedItems = visibleItems.filter(item => item.focused);
            if (!focusedItems.length && visibleItems.length > 0) {
                visibleItems[0].focused = true;
                this.activeDescendant = visibleItems[0].itemId;
            }
        }
        if (this.animate) {
            this.updateAnimate();
        }
    }
    /**
     * @hidden
     */
    onComponentBlur() {
        this.eventService.onBlur();
        this.focused = false;
        this.activeDescendant = "";
    }
    /**
     * @hidden
     */
    onComponentKeyDown(event) {
        if (event.target === this.elementRef.nativeElement) {
            if (event.keyCode === Keys.space || event.keyCode === Keys.up || event.keyCode === Keys.down ||
                event.keyCode === Keys.left || event.keyCode === Keys.right || event.keyCode === Keys.home ||
                event.keyCode === Keys.end || event.keyCode === Keys['page up'] || event.keyCode === Keys['page down']) {
                event.preventDefault();
            }
            const handler = this.keyBindings[event.keyCode];
            //TODO: check if next item is disabled and skip operation?
            if (handler) {
                handler();
            }
        }
    }
    get viewItems() {
        let treeItems = [];
        this.viewChildItems.toArray().forEach(item => {
            treeItems.push(item);
            treeItems = treeItems.concat(item.subTreeViewItems());
        });
        return treeItems;
    }
    validateConfiguration() {
        if (isDevMode()) {
            if (this.items && (this.contentItems && this.contentItems.length > 0)) {
                throw new Error("Invalid configuration: mixed template components and items property.");
            }
        }
    }
    onItemAction(item) {
        if (!item) {
            return;
        }
        let modifiedItems = new Array();
        this.allItems
            .forEach((currentItem) => {
            let selectedState = currentItem === item;
            let focusedState = selectedState;
            selectedState = this.selectable ? selectedState : currentItem.selected;
            if (currentItem.selected !== selectedState || currentItem.focused !== focusedState) {
                currentItem.selected = selectedState;
                currentItem.focused = focusedState;
                this.activeDescendant = focusedState ? currentItem.itemId : "";
                modifiedItems.push(currentItem);
            }
        });
        if (this.expandMode === PanelBarExpandMode.Multiple) {
            if (item.hasChildItems || item.hasContent) {
                item.animate = this.animate;
                item.expanded = !item.expanded;
            }
            if (modifiedItems.indexOf(item) < 0) {
                modifiedItems.push(item);
            }
        }
        else {
            let siblings = item.parent ? item.parent.childrenItems : this.childrenItems;
            if (item.hasChildItems || item.hasContent) {
                siblings
                    .forEach((currentItem) => {
                    let expandedState = currentItem === item;
                    if (currentItem.expanded !== expandedState) {
                        currentItem.animate = this.animate;
                        currentItem.expanded = expandedState;
                        if (modifiedItems.indexOf(currentItem) < 0) {
                            modifiedItems.push(currentItem);
                        }
                    }
                });
            }
        }
        if (modifiedItems.length > 0) {
            this.stateChange.emit(modifiedItems.map(currentItem => currentItem.serialize()));
        }
    }
    get hostClasses() {
        return true;
    }
    isVisible(item) {
        const visibleItems = this.visibleItems();
        return visibleItems.some(i => i === item);
    }
    getVisibleParent(item) {
        const visibleItems = this.visibleItems();
        if (!item.parent) {
            return item;
        }
        return visibleItems.some(i => i === item.parent) ? item.parent : this.getVisibleParent(item.parent);
    }
    focusItem(action) {
        const visibleItems = this.visibleItems();
        let currentIndex = visibleItems.findIndex(item => item.focused);
        let currentItem = visibleItems[currentIndex];
        let nextItem;
        if (currentIndex === -1) {
            let focusedItem = this.allItems.find(item => item.focused);
            focusedItem.focused = false;
            currentItem = this.getVisibleParent(focusedItem);
            currentIndex = visibleItems.findIndex(item => item === currentItem);
        }
        switch (action) {
            case "lastItem":
                nextItem = visibleItems[visibleItems.length - 1];
                break;
            case "firstItem":
                nextItem = visibleItems[0];
                break;
            case "nextItem":
                nextItem = visibleItems[currentIndex < visibleItems.length - 1 ? currentIndex + 1 : 0];
                break;
            case "previousItem":
                nextItem = visibleItems[currentIndex > 0 ? currentIndex - 1 : visibleItems.length - 1];
                break;
            default:
        }
        if (currentItem && nextItem && currentItem !== nextItem) {
            this.moveFocus(currentItem, nextItem);
        }
    }
    moveFocus(from, to) {
        from.focused = false;
        to.focused = true;
        this.activeDescendant = to.itemId;
        const modifiedItems = new Array(from.serialize(), to.serialize());
        this.stateChange.emit(modifiedItems);
    }
    focusLastItem() {
        this.focusItem("lastItem");
    }
    focusFirstItem() {
        this.focusItem("firstItem");
    }
    focusNextItem() {
        this.focusItem("nextItem");
    }
    focusPreviousItem() {
        this.focusItem("previousItem");
    }
    expandItem() {
        let currentItem = this.allItems.filter(item => item.focused)[0];
        if (!this.isVisible(currentItem)) {
            currentItem.focused = false;
            currentItem = this.getVisibleParent(currentItem);
        }
        if (currentItem.hasChildItems || currentItem.hasContent) {
            if (!currentItem.expanded) {
                this.onItemAction(currentItem);
            }
            else if (currentItem.hasChildItems) {
                const firstChildIndex = currentItem.childrenItems.findIndex(item => !item.disabled);
                if (firstChildIndex > -1) {
                    this.moveFocus(currentItem, currentItem.childrenItems[firstChildIndex]);
                }
            }
        }
    }
    collapseItem() {
        const currentItem = this.allItems.filter(item => item.focused)[0];
        if (currentItem.expanded) {
            this.onItemAction(currentItem);
        }
        else if (currentItem.parent) {
            this.moveFocus(currentItem, currentItem.parent);
        }
    }
    selectFocusedItem() {
        let focusedItem = this.allItems.filter(item => item.focused)[0];
        if (!this.isVisible(focusedItem)) {
            focusedItem.focused = false;
            focusedItem = this.getVisibleParent(focusedItem);
        }
        if (focusedItem) {
            focusedItem.onItemAction();
        }
    }
    visibleItems() {
        return this.flatVisibleItems(this.childrenItems);
    }
    flatVisibleItems(listOfItems = new Array(), flattedItems = new Array()) {
        listOfItems.forEach(item => {
            if (!item.disabled) {
                flattedItems.push(item);
                if (item.expanded && item.hasChildItems) {
                    this.flatVisibleItems(item.childrenItems, flattedItems);
                }
            }
        });
        return flattedItems;
    }
};
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], PanelBarComponent.prototype, "expandMode", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], PanelBarComponent.prototype, "selectable", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], PanelBarComponent.prototype, "animate", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], PanelBarComponent.prototype, "height", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [Boolean])
], PanelBarComponent.prototype, "keepItemContent", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Array),
    tslib_1.__metadata("design:paramtypes", [Array])
], PanelBarComponent.prototype, "items", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], PanelBarComponent.prototype, "stateChange", void 0);
tslib_1.__decorate([
    HostBinding('attr.tabIndex'),
    tslib_1.__metadata("design:type", Number)
], PanelBarComponent.prototype, "tabIndex", void 0);
tslib_1.__decorate([
    HostBinding('attr.role'),
    tslib_1.__metadata("design:type", String)
], PanelBarComponent.prototype, "role", void 0);
tslib_1.__decorate([
    HostBinding('attr.aria-activedescendant'),
    tslib_1.__metadata("design:type", String)
], PanelBarComponent.prototype, "activeDescendant", void 0);
tslib_1.__decorate([
    HostBinding('style.height'),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [])
], PanelBarComponent.prototype, "hostHeight", null);
tslib_1.__decorate([
    HostBinding('style.overflow'),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [])
], PanelBarComponent.prototype, "overflow", null);
tslib_1.__decorate([
    HostBinding('attr.dir'),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [])
], PanelBarComponent.prototype, "dir", null);
tslib_1.__decorate([
    ContentChild(PanelBarItemTemplateDirective),
    tslib_1.__metadata("design:type", PanelBarItemTemplateDirective)
], PanelBarComponent.prototype, "template", void 0);
tslib_1.__decorate([
    ContentChildren(PanelBarItemComponent, { descendants: true }),
    tslib_1.__metadata("design:type", QueryList)
], PanelBarComponent.prototype, "contentItems", void 0);
tslib_1.__decorate([
    ContentChildren(PanelBarItemComponent),
    tslib_1.__metadata("design:type", QueryList)
], PanelBarComponent.prototype, "contentChildItems", void 0);
tslib_1.__decorate([
    ViewChildren(PanelBarItemComponent),
    tslib_1.__metadata("design:type", QueryList)
], PanelBarComponent.prototype, "viewChildItems", void 0);
tslib_1.__decorate([
    HostListener('click', ['$event']),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], PanelBarComponent.prototype, "onComponentClick", null);
tslib_1.__decorate([
    HostListener('focus'),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PanelBarComponent.prototype, "onComponentFocus", null);
tslib_1.__decorate([
    HostListener('blur'),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PanelBarComponent.prototype, "onComponentBlur", null);
tslib_1.__decorate([
    HostListener('keydown', ['$event']),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], PanelBarComponent.prototype, "onComponentKeyDown", null);
tslib_1.__decorate([
    HostBinding('class.k-widget'),
    HostBinding('class.k-panelbar'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], PanelBarComponent.prototype, "hostClasses", null);
PanelBarComponent = tslib_1.__decorate([
    Component({
        exportAs: 'kendoPanelbar',
        providers: [PanelBarService],
        selector: 'kendo-panelbar',
        template: `
        <ng-content *ngIf="contentChildItems && !items" select="kendo-panelbar-item"></ng-content>
        <ng-template [ngIf]="items?.length">
            <kendo-panelbar-item
                *ngFor="let item of items"
                 [title]="item.title"
                 [id]="item.id"
                 [icon]="item.icon"
                 [iconClass]="item.iconClass"
                 [imageUrl]="item.imageUrl"
                 [selected]="!!item.selected"
                 [expanded]="!!item.expanded"
                 [disabled]="!!item.disabled"
                 [template]="templateRef"
                 [items]="item.children"
                 [content]="item.content"
            >
            </kendo-panelbar-item>
        </ng-template>
    `
    })
    // TODO: add styles as input prop
    ,
    tslib_1.__param(2, Optional()), tslib_1.__param(2, Inject(RTL)),
    tslib_1.__metadata("design:paramtypes", [ElementRef, PanelBarService, Boolean])
], PanelBarComponent);
export { PanelBarComponent };
