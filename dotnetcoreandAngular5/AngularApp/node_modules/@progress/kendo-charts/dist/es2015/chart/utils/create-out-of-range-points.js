import { INTERPOLATE, ZERO } from '../constants';
import { convertableToNumber } from '../../common';
import SeriesBinder from '../series-binder';

const AREA_REGEX = /area/i;

function seriesMissingValues(series) {
    if (series.missingValues) {
        return series.missingValues;
    }

    return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;
}

function hasValue(series, item) {
    const fields = SeriesBinder.current.bindPoint(series, null, item);
    const valueFields = fields.valueFields;

    for (let field in valueFields) {
        if (convertableToNumber(valueFields[field])) {
            return true;
        }
    }
}

export default function createOutOfRangePoints(series, range, count, getter) {
    const { min, max } = range;
    const hasMinPoint = min > 0 && min < count;
    const hasMaxPoint = max + 1 < count;

    if (hasMinPoint || hasMaxPoint) {
        const missingValues = seriesMissingValues(series);
        let minPoint, maxPoint;
        if (missingValues !== INTERPOLATE) {
            if (hasMinPoint) {
                minPoint = getter(min - 1);
            }

            if (hasMaxPoint) {
                maxPoint = getter(max + 1);
            }
        } else {
            let outPoint, pointHasValue;
            let idx = min;

            if (hasMinPoint) {
                do {
                    idx--;
                    outPoint = getter(idx);
                    pointHasValue = hasValue(series, outPoint.item);
                } while (idx >= 0 && !pointHasValue);

                if (pointHasValue) {
                    minPoint = outPoint;
                }
                outPoint = null;
                pointHasValue = false;
            }

            if (hasMaxPoint) {
                idx = max;
                do {
                    idx++;
                    outPoint = getter(idx);
                    pointHasValue = hasValue(series, outPoint.item);
                } while (idx < count && !pointHasValue);

                if (pointHasValue) {
                    maxPoint = outPoint;
                }
            }
        }

        if (minPoint) {
            series._outOfRangeMinPoint = minPoint;
        }

        if (maxPoint) {
            series._outOfRangeMaxPoint = maxPoint;
        }
    }
}