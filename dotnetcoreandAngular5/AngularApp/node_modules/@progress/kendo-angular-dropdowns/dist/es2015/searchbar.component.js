import * as tslib_1 from "tslib";
/* tslint:disable:member-ordering */
import { Component, Renderer2, Input, Output, HostListener, EventEmitter, ViewChild, ElementRef, HostBinding, Optional, Inject } from '@angular/core';
import { Keys } from './common/keys';
import { combineStr, isDocumentAvailable } from './util';
import { RTL } from '@progress/kendo-angular-l10n';
/**
 * @hidden
 */
let SearchBarComponent = class SearchBarComponent {
    constructor(rtl, renderer) {
        this.valueChange = new EventEmitter();
        this.onBlur = new EventEmitter();
        this.onFocus = new EventEmitter();
        this.onClick = new EventEmitter();
        this.onNavigate = new EventEmitter();
        this._userInput = "";
        this._previousValue = "";
        this._placeholder = "";
        this._composing = false;
        this.direction = rtl ? 'rtl' : 'ltr';
        this.renderer = renderer;
    }
    get userInput() {
        return this._userInput;
    }
    set userInput(userInput) {
        this._userInput = userInput || "";
    }
    get searchBarClass() {
        return true;
    }
    get value() {
        return this.input.nativeElement.value;
    }
    set placeholder(text) {
        this._placeholder = text || '';
        this.setInputSize();
    }
    get placeholder() {
        return this._placeholder;
    }
    compositionStart() {
        this._composing = true;
    }
    compositionUpdate() {
        this._composing = true;
    }
    compositionEnd() {
        this._composing = false;
        this._previousValue = this.value;
        this.valueChange.emit(this.value);
    }
    ngOnChanges(changes) {
        let previousUserInput;
        if (this.input && (changes.userInput || changes.suggestedText)) {
            if (changes.userInput && changes.userInput.previousValue) {
                if (this._previousValue === changes.userInput.previousValue) {
                    previousUserInput = this._previousValue;
                }
                else {
                    previousUserInput = changes.userInput.currentValue || "";
                }
            }
            else {
                previousUserInput = this._previousValue;
            }
            const caretIndex = this.input.nativeElement.selectionStart;
            const caretAtEnd = previousUserInput.length === caretIndex;
            this.writeInputValue(this.suggestedText ? combineStr(this.userInput, this.suggestedText) : this.userInput);
            if (this.suggestedText) {
                this.setInputSelection(this.userInput.length, this.suggestedText.length);
            }
            else if (caretAtEnd) {
                this.setInputSelection(this.userInput.length, this.userInput.length);
            }
            else {
                this.setInputSelection(caretIndex, caretIndex);
            }
            this._previousValue = this.userInput;
        }
    }
    writeInputValue(text) {
        if (isDocumentAvailable()) {
            this.renderer.setProperty(this.input.nativeElement, 'value', text);
        }
    }
    setInputSelection(start, end) {
        if (isDocumentAvailable() && this.input.nativeElement === document.activeElement) {
            try {
                this.input.nativeElement.setSelectionRange(start, end);
            }
            catch (e) {
                //Make sure element is in the DOM before invoking its methods
            }
        }
    }
    handleInput(event) {
        const value = event.target.value;
        if (value !== this.userInput && !this._composing) {
            this._previousValue = value;
            this.valueChange.emit(value);
        }
    }
    handleFocus(event) {
        this.onFocus.emit(event);
    }
    handleBlur(event) {
        this.onBlur.emit(event);
    }
    handleKeydown(event) {
        const keyCode = event.keyCode;
        const keys = [Keys.up, Keys.down, Keys.left, Keys.right, Keys.enter,
            Keys.esc, Keys.delete, Keys.backspace, Keys.home, Keys.end];
        if (keys.indexOf(keyCode) > -1) {
            this.onNavigate.emit(event);
        }
    }
    focus() {
        if (isDocumentAvailable()) {
            this.input.nativeElement.focus();
        }
    }
    blur() {
        if (isDocumentAvailable()) {
            this.input.nativeElement.blur();
        }
    }
    setInputSize() {
        const lengthOf = x => x ? x.length : 0;
        const input = this.input.nativeElement;
        const placeholderLength = lengthOf(this.placeholder);
        const textLength = lengthOf(this.value);
        const size = Math.max(placeholderLength, textLength, 1);
        this.renderer.setAttribute(input, 'size', size.toString());
    }
};
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], SearchBarComponent.prototype, "id", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], SearchBarComponent.prototype, "listId", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], SearchBarComponent.prototype, "activeDescendant", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], SearchBarComponent.prototype, "disabled", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], SearchBarComponent.prototype, "readonly", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], SearchBarComponent.prototype, "tabIndex", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], SearchBarComponent.prototype, "popupOpen", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], SearchBarComponent.prototype, "role", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], SearchBarComponent.prototype, "userInput", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], SearchBarComponent.prototype, "suggestedText", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], SearchBarComponent.prototype, "valueChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], SearchBarComponent.prototype, "onBlur", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], SearchBarComponent.prototype, "onFocus", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], SearchBarComponent.prototype, "onClick", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], SearchBarComponent.prototype, "onNavigate", void 0);
tslib_1.__decorate([
    ViewChild("input"),
    tslib_1.__metadata("design:type", ElementRef)
], SearchBarComponent.prototype, "input", void 0);
tslib_1.__decorate([
    HostBinding('class.k-searchbar'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], SearchBarComponent.prototype, "searchBarClass", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], SearchBarComponent.prototype, "placeholder", null);
tslib_1.__decorate([
    HostListener("compositionstart"),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], SearchBarComponent.prototype, "compositionStart", null);
tslib_1.__decorate([
    HostListener("compositionupdate"),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], SearchBarComponent.prototype, "compositionUpdate", null);
tslib_1.__decorate([
    HostListener("compositionend"),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], SearchBarComponent.prototype, "compositionEnd", null);
SearchBarComponent = tslib_1.__decorate([
    Component({
        selector: 'kendo-searchbar',
        template: `
        <input #input
            autocomplete="off"
            [id]="id"
            [disabled]="disabled"
            [readonly]="readonly"
            [placeholder]="placeholder"
            [class]="'k-input'"
            (input)="handleInput($event)"
            (focus)="handleFocus($event)"
            (blur)="handleBlur($event)"
            (keydown)="handleKeydown($event)"
            [attr.tabIndex]="tabIndex"
            [attr.dir]="direction"
            [attr.role]="role"
            [attr.aria-disabled]="disabled"
            [attr.aria-readonly]="readonly"
            [attr.aria-haspopup]="true"
            [attr.aria-expanded]="popupOpen"
            [attr.aria-owns]="listId"
            [attr.aria-activedescendant]="activeDescendant"
        />
   `
    }),
    tslib_1.__param(0, Optional()), tslib_1.__param(0, Inject(RTL)),
    tslib_1.__metadata("design:paramtypes", [Boolean, Renderer2])
], SearchBarComponent);
export { SearchBarComponent };
